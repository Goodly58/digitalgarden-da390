---
{"dg-publish":true,"permalink":"/1-mw-cmp-321/w1-w2/","title":"Chapter 1 â€” Preliminaries (Programming Languages)","tags":["programming-languages","preliminaries","paradigms","evaluation","compilation"]}
---


# Chapter 1: Preliminaries

---
> [!info]- Info
> ## 1) Languages Index
> 
> ![Pasted image 20260112103538.png](/img/user/1%20-%20MW%20CMP321/img/Pasted%20image%2020260112103538.png)
> 
> > Languages are made to solve a problem. Elixir was used to solve the problem of concurrency.
> ## 2) Programming domains (historical drivers)
> 
> | Domain                  | Era (rough) | Typical needs                               | Example languages      |
> | ----------------------- | ----------: | ------------------------------------------- | ---------------------- |
> | Scientific apps         |         40s | lots of **floating-point**, **arrays**      | Fortran, ALGOL 60      |
> | Business apps           |         50s | reports, **decimal numbers**, characters    | COBOL                  |
> | Artificial Intelligence |         60s | **symbols** > numbers, **linked lists**     | LISP, PROLOG           |
> | Systems programming     |         70s | **efficiency**, continuous use              | PL/I â†’ C (UNIX) â†’ C++  |
> | Web software            |         90s | mix of markup + scripting + general purpose | HTML/XML, PHP/JS, Java |
> 
> > [!note]+ Takeaway
> > Languages often evolve because a *domain* demands certain features (data types, performance, abstraction, tooling).
> 

---

## 3) Language evaluation criteria

### The 4 core criteria
> [!important]+ The â€œbig fourâ€
> - **Readability**: how easily code can be read/understood  
> - **Writability**: how easily code can be created  
> - **Reliability**: conformance to specs; correct under all conditions . **Portability**.
> - **Cost**: total cost of using the language for software.


---

### 3.1 Readability (what improves it?)
![image.png|400x231](/img/user/1%20-%20MW%20CMP321/img/image.png)
- C (iterative) has poorest readability. There is no abstraction. Multiple variables there.
- Haskell  (list) is the highest level of abstraction.

**â†‘** Abstraction, **â†‘** Syntax: Readability.


> [!note]+ Readability factors
> **1) Overall simplicity** 
> - manageable set of constructs (e.g., loops)
> - minimal feature multiplicity (too many ways to do same thing)
> - minimal operator overloading  
>
> **2) Orthogonality**
> - small set of primitives combine in few, consistent ways
> - â€œevery possible combination is legalâ€ (idealized goal)
>
> **3) Data types**
> - adequate predefined types (e.g., Boolean rather than int hacks)
>
> **4) Syntax design**
> - identifiers: flexible but clear
> - compound statements: clear structure (keywords vs braces, etc.)
> - constructs self-descriptive; avoid confusing/multi-meaning keywords


---

### 3.2 Writability (what improves it?)

> [!note]+ Writability factors
> - **Simplicity + orthogonality** (few rules, easy combinations)
> - **Support for abstraction**
>   - *Process abstraction*: define and reuse operations (functions/procedures)
>   - *Data abstraction*: define complex data and hide details
> - **Expressivity**
>   - convenient operators / built-in functions for common tasks

CompareString â€” java
Cmpstr â€” cpp
> [!success]- Which is more readable? more writeable?
> - CompareString is more readable (descriptive name), but less writeable (takes longer to write)
>   - Cmpstr is less readable (compact name), but more writable (takes less time to write) 

else if 
elif
Which is more readable? more writeable?
> [!success]- Solution
> else if is more readable, less writeable
> elif is less readable, more writeable

{ }
begin for   end for
Which is more readable? more writeable?
> [!success]- Solution
> { } less readable more writeable
> begin for, end for â€” more readable, less writeable

3 variations of loops or 1 loop: readability, writability?
> [!success]- Solution
> 
> | **Metric**      | **3 Sequential Loops**                                 | **1 Giant Loop**                                                |
> | --------------- | ------------------------------------------------------ | --------------------------------------------------------------- |
> | **Writability** | **Better.** You solve distinct problems one at a time. | **Worse.** You must solve multiple problems simultaneously.     |
> | **Readability** | **Better.** Scannable chunks.                          | **Worse.** A "wall of logic" inside braces.                     |
> | **Efficiency**  | **Neutral.** (Usually). $O(3N)$ simplifies to $O(N)$.  | **Marginally Better.** Saves loop overhead, but rarely matters. |

x++ vs ++x
> [!success]- Solution
> ![image-1.png|400x358](/img/user/1%20-%20MW%20CMP321/img/image-1.png)
> ![image-2.png|400x101](/img/user/1%20-%20MW%20CMP321/img/image-2.png)

x=x+1
x+=1
x++
++x
> [!success]- FOR THE ABOVE FUNCTIONS: C++ writeability and readability? Python?
> Since c++ has all 4: â†‘ writeability (more options) â†“ readability
> Since python has only first 2: â†“ writeability  (less options) â†‘ readability 

> [!question]- How does operator overloading affect readability? writeability? [quiz 2 question]
> Reduces readability (you don't know what the operator does)
> More writability (gives you flexibility to do what you want).

> [!question]- How does garbage collection affect readability? writeability?
> readability â†‘ (code will be shorter) writeability â†‘ (less to write) performance â†“

```cpp
auto x=1; // type inference (compiler assumes type based on syntax)

//therefore it will write:
int x=1;

auto y=1.0;
//thus:
double y=1.0;

auto z = 1.0f;
//thus:
float z=1.0
```

> [!success]- Which is more writeable? readable? OPTIONAL: reliable?
> â†‘ writeability
> â†“ readability
> ![image-3.png|400x389](/img/user/1%20-%20MW%20CMP321/img/image-3.png)

> [!question]- Comments address which issue?
> Issue: lack of readability

Boolean vs Int
int count = 1;
bool count = true;
In a programming language, having both of the above: readability? writeability?
> [!success]- Solution
> more readable: you know intention with use of bool as opposed to int
> more writeable: having more flexibility (more options)

**Quiz 1 Question:** Which impact the design, implementation, and evolution of a Programming Language?
1. Domain of application
2. Needs of the programmer
3. Policies of IT corporations
4. All of the above
5. None
> [!quiz]- Solution
> All of the above
> ![image-4.png|400x317](/img/user/1%20-%20MW%20CMP321/img/image-4.png)

- int = string
- double = int
- int = double
What will work in Python? C++? Java
> [!success]- Solution
> |**Scenario (x = y)**|**Python**|**C++**|**Java**|
|---|---|---|---|
|**`int = string`**|**Works** (x becomes string)|**Error** (Cannot convert)|**Error** (Incompatible types)|
|**`double = int`**|**Works** (x becomes int)|**Works** (Implicit conversion)|**Works** (Widening conversion)|
|**`int = double`**|**Works** (x becomes float)|**Works** (Truncates decimal!)|**Error** (Prevents data loss)|


**ABSTRACTION**: good for Writeability? readability? performance?
> [!success]- Solution
> +Writeability
> +Readability
> -Performance

---

### 3.3 Reliability (what improves it?)

> [!note]+ Reliability factors
> - **Type checking** (compile-time or run-time)
> - **Exception handling** (catch run-time errors, corrective measures)
> - **Aliasing** (multiple refs to same memory location can reduce reliability)
> - **Readability + writability** matter: unnatural expression â†’ more bugs

f(int)
f(10.2)
What will be the output in C++? Java? Python?
> [!success]- Solution
> |**Language**|**Result of f(10.2) into int x**|**Explanation**|
> |---|---|---|
> |**C++**|**Runs** (`x = 10`)|Implicitly converts (truncates).|
> |**Java**|**Error** (Crash)|Refuses to lose data (Narrowing).|
> |**Python**|**Runs** (`x = 10.2`)|Ignores the type definition entirely.|

Exception handling: writability? readability? reliability?
- without exceptions (C)
- **with exceptions (Java/Python)**
> [!success]- Solution
without exceptions
-writability
-readability
+reliability
with exceptions
> +writability  (errors bubble up; now u have less code to write)
> +readability (logic and error handling are separated)
> +reliability
> 

**Pointer Aliasing**: 2 pointers point to same memory location
Readability? Writability? Reliability? 
> [!success]- Solution
> -Readability
> +Writability (more options)
> -Reliability (more chance of bugs)


**Reliability vs Safety**? [Warning for Exam from Email]
> [!success]- Solution
> Plastic Knife (Safe but Unreliable): You won't hurt yourself (Safe), but it fails to do its job of cutting steak (Unreliable). In software, this is a system that is so locked down with security checks that it becomes too slow or restrictive to be useful.
> 
Unlocked Chainsaw (Reliable but Unsafe): It cuts trees perfectly every time (Reliable), but it might cut your leg off just as easily (Unsafe). In software, this is a system that gives you total power but no protection against mistakes.

- [ ] ask about the above

---

### 3.4 Cost (what counts?)

> [!note]+ Cost factors
> - training programmers
> - writing programs (closeness to applications)
> - compiling programs
> - executing programs (optimization/trade-offs)
> - implementation system (compilers/tools availability)
> - reliability (bugs are expensive)
> - maintenance (often **2â€“5Ã—** initial cost)
> ---
> - portability (moved from one implementation to another)
> - generality (applicable to many applications)
> - well-definedness (how complete is the language's documentation?)

If the language offers garbage collection: cost?
> [!success]- Solution
> With garbage collection, there is less for programmers to learn (because otherwise you'll have to manually do it)
> Less time writing programs
> Lowers compile time (less lines of code)
> More cost affects executing/runtime
> More cost of language implementation system: someone has to implement it.
> Less cost for reliability.
> Less time debugging so less cost.

> [!info] Note
> Keep in mind it can be operator overloading or any other feature and how does it affect cost. Maybe it will be good to write a bunch of features then do readability writeability reliability cost for all.

---

![image-5.png|400x205](/img/user/1%20-%20MW%20CMP321/img/image-5.png)

---

## 4) Influences on language design

> [!info]+ Two major influences
> 1. **Computer architecture** (esp. von Neumann)  
> 2. **Program design methodologies** (structured programming â†’ abstraction â†’ OOP)



---

### 4.1 Architecture: von Neumann influence

> [!note]+ Why imperative languages dominate (historically)
> - Data + programs stored in memory
> - Memory separate from CPU
> - Instructions/data *move* from memory â†’ CPU  
> - Imperative mapping:
>   - **variables** â‰ˆ memory cells
>   - **assignment** â‰ˆ moving/piping values
>   - **iteration** is efficient

> [!example]+ Fetchâ€“execute cycle (mental model)
> 1) initialize program counter  
> 2) repeat forever: fetch â†’ increment â†’ decode â†’ execute

> [!warning]+ Von Neumann bottleneck
> CPU can often execute faster than memoryâ†”CPU connection speed â†’ **bottleneck** limiting performance.

---

### 4.2 Methodologies influence (timeline)

> [!note]+ Methodology shifts â†’ new language features/paradigms
> - **1950sâ€“early 60s**: focus on *machine efficiency*
> - **late 1960s**: focus on *people efficiency*  
>   - structured programming  
>   - top-down design + step-wise refinement  
> - **late 1970s**: process-oriented â†’ *data-oriented*  
>   - data abstraction  
> - **mid 1980s**: **object-oriented**  
>   - data abstraction + inheritance + polymorphism

---

## 5) Language categories (paradigms)

> [!note]+ Main categories
> - **Imperative**
>   - variables, assignment, iteration (often includes OOP + scripting + visual langs)
>   - examples: C, Java, Perl, JavaScript, VB .NET, C++
> - **Functional**
>   - computation by applying functions
>   - examples: LISP, Scheme, ML, F#
> - **Logic**
>   - rule-based (order-independent rules)
>   - example: Prolog
> - **Markup/programming hybrids**
>   - markup extended with programming capabilities
>   - examples: JSTL, XSLT

---

## 6) Language design trade-offs

> [!warning]+ Trade-offs to memorize (with examples)
> - **Reliability vs execution cost**
>   - e.g., array bounds checks improve safety but add overhead
> - **Readability vs writability**
>   - very compact notation can be hard to read (APL-style power operators)
> - **Writability/flexibility vs reliability**
>   - powerful features like pointers can increase risk/bugs

---

## 7) Implementation methods

> [!important]+ Three big approaches
> 1. **Compilation** (incl. JIT systems)  
> 2. **Pure interpretation**  
> 3. **Hybrid systems** (intermediate code + VM)

---

### 7.1 Compilation

> [!note]+ What compilation means
> (compilation is translation)
> Translate **high-level source** â†’ **machine code**  
> - **slow translation, fast execution**

**Common compilation phases**
1. **Lexical analysis**: characters â†’ lexical units (tokens)  
2. **Syntax analysis**: tokens â†’ parse trees  
3. **Semantic analysis**: produce intermediate code  
4. **Code generation**: machine code output  

**Extra terminology**
- **Load module (executable image)**  
    The final executable file that contains:
    - user program code
    - required system/library code
- **Linking and loading**
    - **Linking**: combines your compiled code with:
        - library routines
        - system code
    - **Loading**: places the linked program into memory so it can run

##### **Lexical analysis (tokenization)**
> [!note]+ What it does  
> Converts **characters â†’ tokens** (says what category each lexeme is)

|Lexeme|Token|
|---|---|
|`int`|KEYWORD|
|`x`|IDENTIFIER|
|`=`|OPERATOR|
|`10`|INTEGER_LITERAL|
|`;`|SEMICOLON|

common issues:
- 1x=yâŒ (1x cannot be expressed as a token)

**What you CAN do:**
- \<var> = \<expr>
	- \<var> = \<var>+\<var>
	- a = b + c

- \<var>=\<expr>
	- a=\<var>=\<expr>
	- a=b=c


##### Syntax Analyzer (Parser)
> [!note]+ What it does  
> Checks whether the **sequence of tokens** follows the **grammar rules** of the language

![image-6.png|200](/img/user/1%20-%20MW%20CMP321/img/image-6.png)

Common issue:
- missing semicolon

x y =
> [!success]- Explain process of lexical analyzer â†’ syntax analyzer
> \<var>\<var> = 
> no problem with lexical analysis.
> problem with syntax analyzer. Invalid syntax. operator missing

##### Symbol Table
> [!note]+ What it does  
> data structure used by the compiler to **store information about identifiers** in a program

Records:
- Name (lexeme)
- Type (int, float, â€¦)
- Value

> Check if x and y is defined in Symbol Table. If not, error.

##### Intermediate Code Generator
> [!note]+ What it does  
> **machine-independent representation** of the program after semantic analysis

C: x = y;
Pascal: x := y;
> In all cases, logic is same. 

##### Optimization
> [!note]+ What it does  
> compiler **improves the intermediate code** so the program runs **faster**

- define n=1000
- you use n throughout code
- compiler will replace all instances of n with the size (1000)

loop unrolling
![image-7.png|100](/img/user/1%20-%20MW%20CMP321/img/image-7.png)

tail recursion â†’ loop 

---
### 7.2 Pure Interpretation
_(Slides ~29â€“30)_
> [!note]+ What is pure interpretation?
> 
> - **No translation** to machine code beforehand
>     
> - Source program is **executed directly** by an interpreter
>     
**Characteristics**
- Easier program execution
    - Run-time errors can be reported **immediately**
- **Slower execution**
    - ~10â€“100Ã— slower than compiled programs
- Often requires **more memory**
- Rare today for traditional high-level languages
**Modern comeback**
- Web scripting languages:
    - JavaScript
    - PHP
> [!success]+ Key trade-off
> 
> - **â†‘ readability & debugging**
>     
> - **â†“ execution speed**
>     
---
### 7.3 Hybrid Implementation Systems
_(Slides ~31â€“32)_
> [!note]+ What is a hybrid system?  
> A compromise between **compilation** and **interpretation**
**How it works**
1. Source code â†’ **intermediate code**
2. Intermediate code â†’ interpreted by a **virtual machine**
**Why use it?**
- Faster than pure interpretation
- Easier portability than pure compilation
**Examples**
- **Java**
    - Compiled to **bytecode**
    - Executed on the **JVM**
- **Perl**
    - Partially compiled to detect errors before interpretation
> [!success]+ Key idea
> 
> - Intermediate code = portability + reasonable performance
>     
---
### 7.4 Just-In-Time (JIT) Compilation
_(Slide ~33)_
> [!note]+ What is JIT?  
> A **delayed compiler** inside a hybrid system
**How JIT works**
1. Program is first translated to intermediate code
2. When a function is **called**, it is compiled to machine code
3. Compiled version is **cached** for future calls
**Used in**
- Java
- .NET languages (C#, VB.NET, etc.)
> [!success]+ JIT advantages
> 
> - Faster than interpretation
>     
> - Avoids compiling unused code
>     
---
## 8) Von Neumann Bottleneck
_(Slide ~28)_
> [!warning]+ Von Neumann Bottleneck
> 
> - CPU speed > memory access speed
>     
> - Instructions wait on memory
>     
> - Memoryâ€“CPU connection limits performance
>     
**Why it matters**
- Even fast processors slow down
- Affects **imperative languages** heavily
> [!exam]+ Exam keyword  
> **Primary limiting factor in computer speed**
---
## 9) Preprocessors
_(Slide ~35)_
> [!note]+ What is a preprocessor?  
> A tool that processes source code **before compilation**
**What preprocessors do**
- Expand macros
- Include external files
- Perform textual substitution
**Classic example: C Preprocessor**
- `#include`
- `#define`
- Macro functions (e.g. `#define max(X,Y)`)
> [!warning]+ Risk
> 
> - Can reduce readability
>     
> - Errors are harder to trace (textual substitution)
>     
---
## 10) Programming Environments
_(Slide ~36)_
> [!note]+ Programming environment  
> A **collection of tools** used to develop software
**Examples**
- **UNIX**
    - Command-line tools
    - Often used today via GUI (GNOME, KDE)
- **Microsoft Visual Studio .NET**
    - Large integrated environment
    - Supports many .NET languages
- **NetBeans**
    - Similar to Visual Studio
    - Focused on Java
> [!success]+ Environment â‰  Language  
> Tools support the language, but are not the language itself.
---
## 11) Language Performance Comparison
_(Slide ~34)_
> [!note]+ Performance comparison slide  
> Shows execution time across languages:
> 
> - Fortran
>     
> - Julia
>     
> - Python
>     
> - R
>     
> - Matlab
>     
> - JavaScript
>     
**General takeaway**
- Compiled languages â†’ fastest
- Interpreted languages â†’ slower
- Performance depends on:
    - implementation
    - optimization
    - runtime system
> [!exam]+ Important  
> Language performance â‰  language quality
---
## 12) Chapter 1 Summary
_(Slide ~37)_
> [!summary]+ What you must remember
> 
> - Studying PL concepts:
>     
>     - helps choose languages
>         
>     - makes learning new languages easier
>         
> - **Four core evaluation criteria**
>     
>     - Readability
>         
>     - Writability
>         
>     - Reliability
>         
>     - Cost
>         
> - Language design influenced by:
>     
>     - machine architecture
>         
>     - programming methodologies
>         
> - Three implementation methods:
>     
>     - Compilation
>         
>     - Interpretation
>         
>     - Hybrid systems
>         
---
If you want, next I can:
- ğŸ”¹ Turn this into a **1-page exam cheat sheet**
- ğŸ”¹ Make **exam-style MCQs** from Chapter 1
- ğŸ”¹ Create a **comparison table** (C vs Java vs Python) only from this chapter
- ğŸ”¹ Highlight **â€œexam trigger wordsâ€** your prof is likely to test
Just tell me how you want to study it.