---
{"dg-publish":true,"permalink":"/1-mw-cmp-321/w4/"}
---

# Chapter 3: Describing Syntax and Semantics

> [!abstract] Overview This chapter covers the formal methods used to describe the **syntax** (structure) and **semantics** (meaning) of programming languages, including BNF, attribute grammars, and various semantic description methods.

---

## 1. Introduction

> [!info] Key Definitions
> 
> - **Syntax**: The form or structure of expressions, statements, and program units
>     - Example: `while (boolean_expr) statement`
> - **Semantics**: The meaning of expressions, statements, and program units

### Users of Language Definitions

- Other language designers
- Implementers and testers
- Programmers (the users of the language)

---

## 2. Terminology

| Term                   | Definition                                        | Example                                  |
| ---------------------- | ------------------------------------------------- | ---------------------------------------- |
| **Language**           | A set of sentences                                | —                                        |
| **Sentence/Statement** | A string of characters/lexemes over some alphabet | `index = 2 * count + 17;`                |
| **Lexeme**             | The lowest level syntactic unit of a language     | `*`, `sum`, `begin`                      |
| **Token**              | A category of lexemes                             | identifiers, operators, numeric literals |

> [!example] Lexemes vs Tokens In the statement `index = 2 * count + 17;`
> 
> - **Lexemes**: `index`, `=`, `2`, `*`, `count`, `+`, `17`, `;`
> - **Tokens**: identifier, assign_op, int_literal, mult_op, identifier, add_op, int_literal, semicolon

---

## 3. Formal Definition of Languages

### Recognizers
- A recognition device reads input strings and decides whether they belong to the language
- Example: **Syntax analysis** part of a compiler

### Generators
- A device that generates sentences of a language
- Used to determine if a particular sentence is syntactically correct by comparing it to the structure of the generator

![image-12.png|400x340](/img/user/1%20-%20MW%20CMP321/img/image-12.png)

---

## 4. BNF and Context-Free Grammars
### Context-Free Grammars (CFG)
Theoretical concept (LINGUISTICS)
- Language generators meant to describe syntax of natural languages
- Defined **4 classes of languages** (Chomsky hierarchy)

```
┌─────────────────────────────┐
│  Recursively Enumerable     │ <-- most powerful, hardest to process
│  ┌───────────────────────┐  │
│  │  Context-Sensitive    │  │ <-- symbol table
│  │  ┌─────────────────┐  │  │
│  │  │  Context-Free   │  │  │ <-- PL mostly context-free.
│  │  │  ┌───────────┐  │  │  │
│  │  │  │  Regular  │  │  │  │ <-- too simple
│  │  │  └───────────┘  │  │  │
│  │  └─────────────────┘  │  │
│  └───────────────────────┘  │
└─────────────────────────────┘
```
The lower it is the stricter it is (easier syntax).
The more expressive, the more complex.

**QUIZ 5**
The grammars of PL are typically:
a) Recursively enumerable grammar
b) context-sensitive
c) context-free
d) regular grammars
e) any of the above

### Backus-Naur Form (BNF)
Notation for programmers (COMPUTER SCIENCE)
**BNF** is a specific notation invented by **John Backus** in 1959 to describe the syntax of the Algol programming language. 
- A **meta-language** for programming languages
- **Equivalent to context-free grammars**

---

## 5. BNF Fundamentals

> [!important] Components of BNF
> 
> - **Nonterminal symbols** (abstractions): Represent category of syntactic structures
>     - Written in angle brackets: `<assign>`, `<expr>`
> - **Terminal symbols**: Lexemes or tokens of the language (operations)
> - **Productions/Rules**: Define how nonterminals can be replaced

### Rule Structure
A rule has:
- **Left-hand side (LHS)**: A nonterminal
- **Right-hand side (RHS)**: A string of terminals and/or nonterminals

```bnf
<assign> → <var> = <expression> //total = a + b
```
- Entire line = production (rule). It tells us how left symbol can be replaced.
- \<assign\> → nonterminal
- \<var\> → nonterminal
- = → terminal
- \<expression\> → nonterminal


### Multiple RHS Options

```bnf
//example without else (Rule 1 / Production 1)
<if_stmt> → if <logic_expr> then <stmt>               //v1
//example with else    (Rule 2 / Production 2)
<if_stmt> → if <logic_expr> then <stmt> else <stmt>   //alternative

//base case: only one identifier (Rule 1 / Production 1)
<ident_list> → identifier                             //v1
//recursion for lists (Rule 2 / Production 2)
<ident_list> → identifier, <ident_list>               //alternative

OR YOU CAN SAY IT AS:

<ident_list> → identifier | identifier, <ident_list>
```
You can use the pipe symbol `|` to separate alternatives

### Grammar Components
- **Grammar**: A finite non-empty set of rules
- **Start symbol**: A special nonterminal (e.g., `<program>`)

---

## 6. Example Grammar

```bnf
<program> → <stmts>
<stmts>   → <stmt> | <stmt> ; <stmts>
<stmt>    → <var> = <expr>
<var>     → a | b | c | d
<expr>    → <term> + <term> | <term> - <term>
<term>    → <var> | const
```

---

## 7. Derivations

> Starting from the rule/syntax, then replacing placeholders with actual variable names, values, etc.

> [!important] Rule
> Always derive from LEFT → RIGHT


![image-13.png|400x195](/img/user/1%20-%20MW%20CMP321/img/image-13.png)
> Ordered by higher importance to lowest importance


If you have a=b how would lexical analyzer react? syntax analyzer?
> [!success]- Solution
> no problem in lexical analyzer.
> syntax analyzer sees that expression means term + term so it cant just be b

What about a=b+x?
> [!success]- Solution
> trigger lexical analyzer because \<var\> lists only a,b,c,d.

`<program>`
show **derivation** steps until a=b+5
> [!success]- Solution
> ```bnf
> <program> => <stmts>
> => <stmt>
> => <var>=<expr>
> => a=<term>+<term>
> => a=<var>+<term>
> => a=b+<term>
> => a=b+<const>
> => a=b+5
> ```

show **recognition** steps from a=b+5
> [!success]- Solution
> ```bnf
> a = b + 5
> <var> = b + 5          (a → <var>)
> <var> = <var> + 5       (b → <var>)
> <var> = <term> + 5      (<var> → <term>)
> <var> = <term> + <const> (5 → <const>)
> <var> = <term> + <term>  (<const> → <term>)
> <var> = <expr>          (<term> + <term> → <expr>)
> <stmt>                  (<var> = <expr> → <stmt>)
> <stmts>                 (<stmt> → <stmts>)
> <program>               (<stmts> → <program>) ✓
> ```


![image-14.png|400x164](/img/user/1%20-%20MW%20CMP321/img/image-14.png)
Do derivation till "cute small cats sleep"
> [!success]- Solution
> ```bnf
> <sentence> -> <np> <vp>
> -> <adj> <np> <vp>
> -> cute <np> <vp>
> -> cute <adj> <np> <vp>
> -> cute small <np> <vp>
> -> cute small <noun> <vp>
> -> cute small cats <vp>
> -> cute small cats sleep
> ```

draw the parse tree
> [!success]- Solution
> ![image-15.png|400x421](/img/user/1%20-%20MW%20CMP321/img/image-15.png)

do recognition for "cats eat small birds"
> [!success]- Solution
> ![image-17.png|400x376](/img/user/1%20-%20MW%20CMP321/img/image-17.png)
> syntax error

![image-16.png|400x130](/img/user/1%20-%20MW%20CMP321/img/image-16.png)

`int x = x;` works 


**QUIZ 6**
```
Grammar:
<s> -> a <s> c | <T> b
<T> -> epsilon (empty) | <T> t

a) abc
b) aabcc
c) aabtcc
d) aatbcc
e) aattbcc

which cannot be generated by grammar?
```

> [!success]- Solution
> C


**QUIZ 7**
**Which of the sentences below cannot be generated by the grammar on the right?**

a) aacbcbc
b) aaccbcbcc
c) aadbcbc
d) aadccbbcc
e) adcdcbc

```
<S> → a <S> b <C> | <C> | <D>
<C> → c <C> | c
<D> → d | d <C> | d <D>
```

> [!success]- Solution
> **Answer: d and e**
> - d: You can't have b and b together.
> - e: you cant produce dcdc


### Key Terms

| Term                         | Definition                                   |
| ---------------------------- | -------------------------------------------- |
| **Sentential form**          | Any string of symbols in a derivation        |
| **Sentence**                 | A sentential form with only terminal symbols |
| **Leftmost derivation**      | Always expand the leftmost nonterminal ⭐     |
| ~~**Rightmost derivation**~~ | ~~Always expand the rightmost nonterminal~~  |

#### Recursion
tail recursion (recursive part at end) → optimized into loop (1:1 equivalent)

```bnf
<ident_list> → <ident_list>, identifier
               ^^^^^^^^^^^^
               At the START = head recursion
               
<ident_list> → identifier, <ident_list>
                           ^^^^^^^^^^^^
                           At the END = tail recursion
```

Math induction can be called as recursion
![image-10.png|400x85](/img/user/1%20-%20MW%20CMP321/img/image-10.png)

Derivation of recursive function
```bnf
<ident_list> → <ident> (if base case this is end of expanding)

<ident_list> → <ident>, <ident_list>
			 → a, <ident_list>  <-- can be replaced by base case
			 → a, <ident>       <-- <ident> is base case
			 → a, b

<ident_list>
→ <ident>, <ident_list>          // Apply Rule 2 (recursive)
→ a, <ident_list>                // Replace <ident> with "a"
→ a, <ident>, <ident_list>       // Apply Rule 2 again (recursive)
→ a, b, <ident_list>             // Replace <ident> with "b"
→ a, b, <ident>                  // Apply Rule 1 (BASE CASE - stop!)
→ a, b, c                        // Replace <ident> with "c"
```
*Reminder: Identifiers are names programmers decide (variables, functions, classes)
![image-11.png|400x114](/img/user/1%20-%20MW%20CMP321/img/image-11.png)


```bnf
//Define a single rule that defines digit
<digit> → 0|1|2|...|9

//Define a single rule that defines integer
<int> → <digit>
	  → <digit> <int> 
```


---

## 9. Parse Trees

> [!info] Parse Tree 
> A **hierarchical representation** of a derivation that is **language independent**.

The same parse tree for `a = b + 5` applies across languages:

|Language|Syntax|
|---|---|
|Python|`a = b + 5`|
|C++/Java|`a = b + 5;`|
|Pascal|`a := b + 5`|
|R|`a <- b + 5`|
|Lisp|`(set! a (+ b 5))`|

---

## 10. Ambiguity in Grammars

> [!warning] Ambiguous Grammar
> A grammar is **ambiguous** if and only if it generates a sentential form that has **two or more distinct parse trees**.

### Ambiguous Expression Grammar

```bnf
<expr> → <expr> <op> <expr> | const
<op>   → / | -
```

For `const - const / const`, two different parse trees are possible!
![image-18.png|300](/img/user/1%20-%20MW%20CMP321/img/image-18.png)

- (6-4)/2
- 6-(4/2)
Which of the above is for left parse tree? which is for right?
> [!success]- Solution
> 

"**It's ambiguous**, THEREFORE we can have at least two parse trees"

> [!question] What's the issue?
> The two recursive calls are the issue.

### Unambiguous Version

Use precedence levels to eliminate ambiguity:

```bnf
<expr> → <expr> - <term> | <term>
<term> → <term> / const | const
```

![image-19.png|150](/img/user/1%20-%20MW%20CMP321/img/image-19.png)

### The Dangling Else Problem

> [!danger] Classic Ambiguity: If-Then-Else
> 
> ```bnf
> <if_stmt> → if <logic_expr> then <stmt>
>           | if <logic_expr> then <stmt> else <stmt>
> ```
> 
> The statement:
> 
> ```
> if done == true
>   then if denom == 0
>     then quotient = 0
>   else quotient = num / denom
> ```
> 
> Can be parsed in **two different ways**!
> (it doesnt know if "else" is for the first `if` or the second `if`)

![image-20.png|400x264](/img/user/1%20-%20MW%20CMP321/img/image-20.png)

### Unambiguous ITE Grammar

```bnf
<stmt>      → <matched> | <unmatched>
<matched>   → if <logic_expr> then <matched> else <matched>
            | any non if_stmt
<unmatched> → if <logic_expr> then <stmt>
            | if <logic_expr> then <matched> else <unmatched>
```



---

## 11. Operator Associativity

**Ambiguous**: `<expr> → <expr> + <expr>` (two recursive terms)
![image-22.png|400x328](/img/user/1%20-%20MW%20CMP321/img/image-22.png)
→ `const + (const + const)` OR `(const + const) + const`

Unambiguous
![image-23.png|400x357](/img/user/1%20-%20MW%20CMP321/img/image-23.png)

### Left Associativity
(left to right)

```bnf
<expr> → <expr> + const | const
```

For `const + const + const`: evaluates left-to-right as `(const + const) + const`

### Right Associativity
(right to left)

```bnf
<factor> → <expr> ** <factor> | <expr>
<expr>   → ( <expr> ) | const
```

![image-21.png|400x295](/img/user/1%20-%20MW%20CMP321/img/image-21.png)

For `const ** const ** const`: evaluates right-to-left as `const ** (const ** const)`

---

## 12. Extended BNF (EBNF)

> [!success] EBNF Enhancements EBNF adds convenient notation to make grammars more readable and concise.

### EBNF Features

|Feature|BNF|EBNF|
|---|---|---|
|**Alternatives in parentheses**|`<term> → <term> + const \| <term> - const`|`<term> → <term> (+\|-) const`|
|**Optional parts** (brackets `[]` or `?`)|`<proc_call> → ident () \| ident (<expr_list>)`|`<proc_call> → ident '('[<expr_list>]')'`|
|**Zero or more** (braces `{}` or `*`)|`<dec_part> → <digits> \| ''`|`<dec_part> → {<digit>}` or `<digit>*`|
|**One or more** (`{}+` or `+`)|`<stmts> → <stmt> \| <stmt> <stmts>`|`<stmts> → {<stmt>}+` or `<stmt>+`|

### BNF vs EBNF Example

**BNF:**

```bnf
<expr> → <expr> + <term>
       | <expr> - <term>
       | <term>
```

**EBNF:**

```ebnf
<expr> → <term> {(+ | -) <term>}
```

---

## 13. Static Semantics

> [!caution] Limitations of CFGs Context-free grammars **cannot describe all** syntax of programming languages.

### Problematic Categories

1. **Context-free but cumbersome**: Types of operands in expressions
2. **Non-context-free**: Variables must be declared before use

---

## 14. Attribute Grammars

> [!abstract] Definition **Attribute grammars** extend CFGs with:
> 
> - **Attributes**: Values associated with grammar symbols
> - **Computation functions**: Define how attributes are calculated
> - **Predicate functions**: Check attribute consistency

### Primary Uses

- Static semantics specification
- Compiler design (static semantics checking)

### Formal Definition

An attribute grammar is a CFG **G = (S, N, T, P)** with:

1. For each grammar symbol **x**: a set of attribute values
2. For each rule: functions defining certain attributes
3. For each rule: predicates to check attribute consistency

### Attribute Types

|Type|Direction|Definition|
|---|---|---|
|**Synthesized**|Bottom-up ↑|`S(X₀) = f(A(X₁), ..., A(Xₙ))`|
|**Inherited**|Top-down ↓|`I(Xⱼ) = f(A(X₀), ..., A(Xₙ))`|
|**Intrinsic**|Leaf nodes|Initial values (e.g., type of variables)|

### Example: Type Checking

```bnf
<assign> → <var> = <expr>
<expr>   → <var> + <var> | <var>
<var>    → A | B | C
```

**Attributes:**

- `actual_type`: synthesized for `<var>` and `<expr>` ∈ {int, real}
- `expected_type`: inherited for `<expr>` ∈ {int, real}

**Semantic Rules:**

```
Syntax rule:  <expr> → <var>[1] + <var>[2]
Semantic rule: <expr>.actual_type ← <var>[1].actual_type

Predicate:
  <var>[1].actual_type == <var>[2].actual_type
  <expr>.expected_type == <expr>.actual_type

Syntax rule:  <var> → A | B | C
Semantic rule: <var>.actual_type ← lookup(<var>.string)
```

### Attribute Computation Order

- **All inherited** → Top-down
- **All synthesized** → Bottom-up
- **Mixed** → Combination of both

---

## 15. Dynamic Semantics

> [!quote] The Challenge There is **no single widely acceptable** notation or formalism for describing semantics.

### Why We Need Formal Semantics

- Programmers need to know what statements mean
- Compiler writers must know exactly what constructs do
- Correctness proofs would be possible
- Compiler generators would be possible
- Designers could detect ambiguities and inconsistencies

---

## 16. Operational Semantics

> [!info] Core Idea Describe meaning by **executing statements** on a machine. The **change in state** (memory, registers) defines the meaning.

### Approaches

|Approach|Description|Issues|
|---|---|---|
|Hardware interpreter|Pure execution on real hardware|Too expensive|
|Software interpreter|Simulation|Machine-dependent, hard to understand|
|**Complete computer simulation**|Translator + idealized computer simulator|**Best approach**|

### Example: C `for` Loop

**C Statement:**

```c
for (expr1; expr2; expr3) { ... }
```

**Operational Meaning:**

```
expr1;
loop: if expr2 == 0 goto end
      ...
      expr3;
      goto loop
end:  ...
```

### Levels of Operational Semantics

- **Natural (big-step)**: One step for entire construct
- **Structural (small-step)**: Step-by-step evaluation

> [!success] Evaluation
> 
> - ✅ Good for language manuals and teaching
> - ❌ Extremely complex if used formally

---

## 17. Denotational Semantics

> [!abstract] Foundation Based on **recursive function theory**. The most **abstract** semantics description method.
> 
> Developed by **Scott and Strachey** (1970).

### The Process

1. Define a **mathematical object** for each language entity
2. Define a **function** that maps language instances to mathematical objects

### Program State

$$s = {\langle i_1, v_1 \rangle, \langle i_2, v_2 \rangle, \ldots, \langle i_n, v_n \rangle}$$

**VARMAP function:** Given a variable name and state, returns the current value: $$\text{VARMAP}(i_j, s) = v_j$$

### Example: Binary Numbers

**Syntax:**

```bnf
<bin_num> → '0' | '1' | <bin_num> '0' | <bin_num> '1'
```

**Semantics:** $$M_{bin}('0') = 0$$ $$M_{bin}('1') = 1$$ $$M_{bin}(\langle bin_num \rangle '0') = 2 \times M_{bin}(\langle bin_num \rangle)$$ $$M_{bin}(\langle bin_num \rangle '1') = 2 \times M_{bin}(\langle bin_num \rangle) + 1$$

### Assignment Statement Semantics

```
Mₐ(x := E, s) ≜
  if Mₑ(E, s) == error
    then error
  else s' = {⟨i₁,v₁'⟩, ⟨i₂,v₂'⟩, ..., ⟨iₙ,vₙ'⟩}
    where for j = 1, 2, ..., n,
      if iⱼ == x then vⱼ' = Mₑ(E, s)
      else vⱼ' = VARMAP(iⱼ, s)
```

### Loop Semantics (Pretest)

```
Mₗ(while B do L, s) ≜
  if Mᵦ(B, s) == undef then error
  else if Mᵦ(B, s) == false then s
  else if Mₛₗ(L, s) == error then error
  else Mₗ(while B do L, Mₛₗ(L, s))
```

> [!tip] Key Insight Loop iteration is converted to **recursion**, which is easier to describe with mathematical rigor.

> [!success] Evaluation
> 
> - ✅ Used to prove program correctness
> - ✅ Rigorous way to think about programs
> - ✅ Aid to language design
> - ✅ Used in compiler generation systems
> - ❌ Complex; limited use for language users

---

## 18. Axiomatic Semantics

> [!abstract] Foundation Based on **formal logic** (predicate calculus). Original purpose: **Formal program verification**.

### Core Concepts

|Term|Definition|
|---|---|
|**Assertion**|A logic expression about program state|
|**Precondition**|Assertion before a statement (relationships/constraints among variables)|
|**Postcondition**|Assertion after a statement|
|**Weakest precondition**|Least restrictive precondition guaranteeing the postcondition|

### Pre/Post Form

$${P} \text{ statement } {Q}$$

### Example

```
{b > 0} a = b + 1 {a > 1}
```

- Postcondition: `{a > 1}`
- One possible precondition: `{b > 10}`
- **Weakest precondition**: `{b > 0}`

---

### Axiom for Assignment

$${Q_{x \rightarrow E}} \text{ x = E } {Q}$$

> [!example] Examples
> 
> ```
> {x > 3} x = x - 3 {x > 0}    ✓
> {x > 5} x = x - 3 {x > 0}    ✓ (because {x > 5} ⇒ {x > 3})
> ```

### Rule of Consequence

$$\frac{{P'} S {Q'}}{{P} S {Q}}, \quad P' \Rightarrow P, \quad Q \Rightarrow Q'$$

---

### Inference Rule for Sequences

$$\frac{{P_1} S_1 {P_2}, \quad {P_2} S_2 {P_3}}{{P_1} S_1; S_2 {P_3}}$$

> [!example] Example
> 
> ```
> {x > 5} x = x - 3 {x > 2} ⇒ {x > 0} x += 1 {x > 1}
> ```

---

### Inference Rule for Selection

$$\frac{{B \land P} S_1 {Q}, \quad {\neg B \land P} S_2 {Q}}{{P} \text{ if B then } S_1 \text{ else } S_2 {Q}}$$

---

### Inference Rule for Loops

$$\frac{{I \land B} S {I}}{{I} \text{ while B do S } {I \land \neg B}}$$

Where **I** is the **loop invariant** (inductive hypothesis).

### Loop Invariant Properties

> [!important] The loop invariant must satisfy:
> 
> 1. **P ⇒ I** — must be true initially
> 2. **{I} B {I}** — evaluation of Boolean must not change it
> 3. **{I ∧ B} S {I}** — not changed by executing the body
> 4. **(I ∧ ¬B) ⇒ Q** — if I is true and B is false, Q is implied
> 5. **Loop terminates** — can be difficult to prove

> [!tip] Finding Loop Invariants The loop invariant I is a **weakened version** of the postcondition, applied as a precondition. It must be:
> 
> - Weak enough to be satisfied prior to the loop
> - Strong enough (when combined with loop exit) to force the postcondition

---

### Evaluation of Axiomatic Semantics

> [!success] Strengths
> 
> - Good tool for correctness proofs
> - Excellent framework for reasoning about programs

> [!failure] Weaknesses
> 
> - Developing axioms for all statements is difficult
> - Not as useful for language users and compiler writers

---

## 19. Comparison of Semantic Methods

|Aspect|Operational|Denotational|Axiomatic|
|---|---|---|---|
|**Basis**|State changes via algorithms|Mathematical functions|Formal logic|
|**Abstraction**|Low|High|Medium|
|**Primary Use**|Manuals, teaching|Proofs, compiler gen|Verification|
|**Complexity**|Medium|High|High|

> [!quote] Key Difference
> 
> - **Operational**: State changes defined by **coded algorithms**
> - **Denotational**: State changes defined by **rigorous mathematical functions**

---

## 20. Summary

> [!success] Key Takeaways
> 
> **Syntax Description:**
> 
> - BNF and CFGs are equivalent meta-languages
> - Well-suited for describing programming language syntax
> - EBNF provides more concise notation
> 
> **Static Semantics:**
> 
> - Attribute grammars describe both syntax and (some) semantics
> - Use synthesized and inherited attributes
> 
> **Dynamic Semantics:**
> 
> - Three primary methods: Operational, Axiomatic, Denotational
> - Each has different strengths and use cases

---

## Appendix: BNF for Propositional Logic

```bnf
Sentence            → AtomicSentence | ComplexSentence
AtomicSentence      → LogicalConstant | PropositionalSymbol
ComplexSentence     → (Sentence)
                    | Sentence LogicalConnective Sentence
                    | ¬Sentence
LogicalConstant     → TRUE | FALSE
PropositionalSymbol → P | Q | R | ...
LogicalConnective   → ∧ | ∨ | ⇔ | ⇒ | ¬
```

**Precedence** (highest to lowest): ¬, ∧, ∨, ⇒, ⇔

> [!example] `¬P ∧ Q ∨ R ⇒ S` is equivalent to `((¬P) ∧ Q) ∨ R) ⇒ S`

---

#programming-languages #syntax #semantics #BNF #compilers #formal-methods