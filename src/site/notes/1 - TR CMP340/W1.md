---
{"dg-publish":true,"permalink":"/1-tr-cmp-340/w1/"}
---


Possible exam Qs:
Give algorithm, validate/analyze correctness, find time complexity, and optimize something within the code. If we change code from X to Y, what is the impact on time/space complexity.

NOT:
write program from scratch

> [!note]
> read the table column by column (the columns are unrelated, it's NOT row by row)

GIVEN IN EXAM:
$\sum^n_{i=1}i=1+2+3+\dots+n=\frac{n(n+1)}{2}$
$\frac{\text{(last value)} \times \text{(last value + 1)}}2$
> [!success]- Simplify $\sum_{i=0}^{s-2}i$
> $\frac{(s-2)(s-1)}{2}$

Covered: Lecture 1, Lecture 2 Slides

---
### Computing factorial

Compute this value
$\sum_{i=1}^{n} i! \;=\; 1! + 2! + 3! + \dots + n!$

```cpp
int n; cin >> n;
int sum = 0;

for (int i = 1; i <= n; i++) {  // runs n times
    int f = 1;

    for (int j = 2; j <= i; j++)  // runs (i−1) times
        f *= j;          // compute i!

    sum += f;            // add i! to the total
}

cout << sum << endl;
```


![Pasted image 20260113124359.png|300](/img/user/1%20-%20TR%20CMP340/img/Pasted%20image%2020260113124359.png)

try this algorithm for n=4 (draw table)
> [!success]- Solution
> |**n**|**sum**|**i**|**f**|**j**|**Comment**|
|---|---|---|---|---|---|
|**4**|**9**|**4**|**1**|**-**|_Outer loop starts for i=4. f resets to 1._|
||||**2**|**2**|_Inner loop: f = 1 * 2_|
||||**6**|**3**|_Inner loop: f = 2 * 3_|
||||**24**|**4**|_Inner loop: f = 6 * 4 (Now f is 4!)_|
|**4**|**33**|**4**|**24**||_Sum = 9 + 24. Loop ends._|
> ![image-4.png|400x182](/img/user/1%20-%20TR%20CMP340/img/image-4.png)

What is the time complexity?
> [!success]- Solution
> $O(n^2)$ — This is because both outer loop and inner loop have `i/j < variable that depends on an input size` AND `inner loop keeps resetting`
> n(n-1)/2

How to make this code faster?
> [!success]- Solution
> ```cpp
1!=1
2!=2
3!=6
>
>```cpp
>int n; cin>>n;
>int sum=0;
>int f=1;
>for (int i=1; i<=n; i++) {
>	f*=i; //i=1 f=1, i=2 f=2, i=3 f=6 
>	sum+=f; //1+2+6+...
>	
>}
>```
> // This loop runs N times. Total time: O(N).

```cpp
int n; cin >> n;
int sum = 0, f = 1;

for (int i = 1; i <= n; i++) {
    f *= i;      // now f becomes i!
    sum += f;    // add i! to sum
}

cout << sum << endl;
```

Try this new algorithm for n=3 (draw table)
> [!success]- Solution
> ![Pasted image 20260113125213.png](/img/user/1%20-%20TR%20CMP340/img/Pasted%20image%2020260113125213.png)

What is the time complexity?
> [!success]- Solution
> $O(n)$

### Finding Mode

#### V1 (Unsorted list)

```cpp
#include <iostream>
using namespace std;

int main() {
    // Input list
    int list[4] = {6, 5, 3, 6};

    // Assume first element is the mode initially
    int mode = list[0];
    int freq = 1;   // highest frequency found so far

    // Outer loop: pick each element one by one
    for (int i = 0; i < 3; i++) {

        int m = list[i]; // current value to count
        int f = 1;       // frequency of current value

        // Inner loop: count occurrences of m after index i
        for (int j = i + 1; j < 4; j++) {
            if (m == list[j]) {
                f++;     // increment count if match found
            }
        }

        // If current value occurs more times than previous mode
        if (f > freq) {
            mode = m;    // update mode
            freq = f;    // update highest frequency
        }
    }

    // Output the mode
    cout << mode << endl;

    return 0;
}
```

Find a trend (mode) in a list of integer values.

> [!success]- Solution
> ![Pasted image 20260113125935.png](/img/user/1%20-%20TR%20CMP340/img/Pasted%20image%2020260113125935.png)

Exercise. Modify the code to handle a list with seven values:  
6,6,3,3,5,5,5. 
Show the execution of the new code as done in the table above

```cpp
int main() {

    int list[7] = {6, 6, 3, 3, 5, 5, 5};
    int mode = list[0];
    int freq = 1;  

    for (int i = 0; i < 6; i++) {
        int m = list[i];
        int f = 1;      

        for (int j = i + 1; j < 7; j++) {
            if (m == list[j]) {
                f++;     
            }
        }

        if (f > freq) {
            mode = m; 
            freq = f;    
        }
    }
  
    cout << mode << endl;
    return 0;
}
```

#### V2 (Sorted list)

```cpp
#include <iostream>
using namespace std;

int main() {
    // Sorted list
    int list[5] = {3, 3, 5, 5, 5};

    // Current mode and its highest frequency
    int mode = list[0], freq = 1;

    // Track current value and its frequency
    int m = list[0], f = 1;

    // Single pass through the list
    for (int i = 0; i < 4; i++) {

        // If next element is the same, increase count
        if (list[i] == list[i + 1]) {
            f++;
        }
        // Value changed → check and reset
        else {
            if (f > freq) {
                mode = m;
                freq = f;
            }
            m = list[i + 1];  // move to next value
            f = 1;            // reset frequency
        }
    }

    // Final check (handles last value)
    if (f > freq) {
        mode = m;
        freq = f;
    }

    // Output the mode
    cout << mode << endl;
    return 0;
}
```

Find a trend (mode) in a list of integer values sorted in ascending order

> [!success]- Solution
> ![Pasted image 20260113131058.png](/img/user/1%20-%20TR%20CMP340/img/Pasted%20image%2020260113131058.png)

### Matrix Multiplication

```cpp
#include <iostream>
using namespace std;

int main() {
    // Matrix A (2x3)
    int A[2][3] = {
        {1, 2, 1},
        {1, 2, 1}
    };

    // Matrix B (3x2)
    int B[3][2] = {
        {1, 2},
        {1, 2},
        {1, 2}
    };

    // Result matrix C (2x2)
    int C[2][2];

    // Matrix multiplication: C = A * B
    for (int i = 0; i < 2; i++) {          // rows of A
        for (int j = 0; j < 2; j++) {      // columns of B
            C[i][j] = 0;                   // initialize cell
            for (int k = 0; k < 3; k++) {  // shared dimension
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }

    // Print matrix C
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            cout << C[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```

pseudocode:
for each row i in A
	for each col j in B
		multiply i by j (third loop)

Exercise 1  
I. Show the calculations of the elements of the matrix C  

> [!success]- Solution
> C[0][0]=  A[0][0]*B[0][0] +A[0][1]*B[1][0]+A[0][2]*B[2][0] = (1)(1) + (2)(1) + (1)(1) = 4
> ...
> 4 8
> 4 8

II. Trace/draw table

> [!success]- Solution
> 
> | i (A's rows) | j (B's columns) | k         |
> | ------------ | --------------- | --------- |
> | ~~0~~        | ~~0~~           | ~~0~~     |
> | ~~1~~        | ~~1~~           | ~~1~~     |
> | 2 (stop)     | ~~2~~           | ~~2~~     |
> |              | ~~0~~           | ~~3~~     |
> |              | ~~1~~           | ~~**0**~~ |
> |              | 2 (stop)        | ~~1~~     |
> |              |                 | ~~2~~     |
> |              |                 | ~~3~~     |
> |              |                 | ~~**0**~~ |
> |              |                 | ~~1~~     |
> |              |                 | ~~2~~     |
> |              |                 | ~~3~~     |
> |              |                 | ~~**0**~~ |
> |              |                 | ~~1~~     |
> |              |                 | ~~2~~     |
> |              |                 | 3 (stop)  |
> 
> C:
> 
> | ~~0~~<br>~~1~~<br>~~3~~<br>4 | ~~0~~<br>~~2~~<br>~~6~~<br>8 |
> | ---------------------------- | ---------------------------- |
> | ~~0~~<br>~~1~~<br>~~3~~<br>4 | ~~0~~<br>~~2~~<br>~~6~~<br>8 |
> 

Exercise 2  
Generalize the algorithm such that A has m  
rows with n columns, B has n rows with p  
columns, and hence C will have m rows  
with p columns ⭐

> [!success]- Solution
> $A_{m\times n}$
> $B_{n\times p}$
> ```cpp
> #include <iostream>
> #include <vector>
> using namespace std;
> 
> // Read a matrix of size r x c
> void readMatrix(vector<vector<int>>& X, int r, int c) {
>     for (int i = 0; i < r; i++)
>         for (int j = 0; j < c; j++)
>             cin >> X[i][j];
> }
> 
> int main() {
>     int m, n, p; 
>     // Read dimensions
>     cin >> m >> n >> p;
> 
>     // Declare matrices
>     vector<vector<int>> A(m, vector<int>(n));
>     vector<vector<int>> B(n, vector<int>(p));
>     vector<vector<int>> C(m, vector<int>(p));
> 
>     // Read matrices A and B
>     readMatrix(A, m, n);
>     readMatrix(B, n, p);
> 
>     // Matrix multiplication: C = A * B
>     for (int i = 0; i < m; i++) {
>         for (int j = 0; j < p; j++) {
>             C[i][j] = 0;
>             for (int k = 0; k < n; k++) {
>                 C[i][j] += A[i][k] * B[k][j];
>             }
>         }
>     }
> 
>     // Output matrix C
>     for (int i = 0; i < m; i++) {
>         for (int j = 0; j < p; j++) {
>             cout << C[i][j] << " ";
>         }
>         cout << endl;
>     }
> 
>     return 0;
> }
> ```

## Greatest Common Divisor

```cpp
#include <iostream>
using namespace std;

int main() {
    int m, n, gcd;
    cin >> m >> n;

    // Ensure m <= n (we swap if true)
    if (m > n) {
        int x = m;
        m = n;
        n = x;
    }

    // Find GCD by checking divisors from m down to 1
    for (int i = m; i >= 1; i--) {
        if (n % i == 0 && m % i == 0) {
            gcd = i;
            break;
        }
    }

    cout << gcd << endl;
    return 0;
}
```

Let m=18, n=12, run the algorithm to find the greatest common divisor

> [!success]- Solution
> ![image-5.png|400x232](/img/user/1%20-%20TR%20CMP340/img/image-5.png)

> [!success]- How many number of operations?
> max(n, m) (whichever is largest)

> [!success]- More efficient algorithm?
> Euclid's algorithm
> ![image.png|400x144](/img/user/1%20-%20TR%20CMP340/img/image.png)


## Time Functions

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int X[n];

    // Read array elements
    for (int i = 0; i < n; i++) {
        cin >> X[i];
    }

    int sum = 0;

    // Compute sum
    for (int i = 0; i < n; i++) {
        sum = sum + X[i];
    }

    cout << sum << endl;
    return 0;
}
```

Time function (count of iterations)?
> [!success]- Solution
> ![image-6.png|400x233](/img/user/1%20-%20TR%20CMP340/img/image-6.png)
> $T(n)=\sum_{i=0}^{n-1}1+\sum_{i=0}^{n-1}1$
> ![image-1.png|400x202](/img/user/1%20-%20TR%20CMP340/img/image-1.png)
> $1((n-1)-0+1)+1((n-1)-0+1)$
> $T(n)=n+n=2n$

Time complexity?
> [!success]- Solution
> O(n)


```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int X[n][n];

    // Read matrix elements
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> X[i][j];
        }
    }

    int max = X[0][0];

    // Find maximum element
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (X[i][j] > max) {
                max = X[i][j];
            }
        }
    }

    cout << "max= " << max << endl;
    return 0;
}
```

Program finds max integer in an integer square matrix.

Time function?
> [!success]- Solution
> ![image-7.png|400x266](/img/user/1%20-%20TR%20CMP340/img/image-7.png)
> $T(n) = \sum_{i=0}^{n-1} \sum_{j=0}^{n-1} 1
>       + \sum_{i=0}^{n-1} \sum_{j=0}^{n-1} 1$
> $T(n) = \sum_{i=0}^{n-1} n + \sum_{i=0}^{n-1} n$
> $
> \color{red}{
> \sum_{i=0}^{n-1} n
> = n \cdot \big((n - 1) - 0 + 1\big)
> = n \cdot n
> = n^2
> }
> $
> $T(n) = n^2 + n^2 = 2n^2$

Time complexity?
> [!success]- Solution
> $O(n^2)$


```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int sum = 0;

    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= n; j++) {
            sum = sum + j;
        }
    }

    cout << sum << endl;
    return 0;
}
```

This algorithm finds the sum:
$\sum_{i=1}^n\sum^n_{j=i}j$

> [!success]- What is the time function?
> ![image-8.png|400x408](/img/user/1%20-%20TR%20CMP340/img/image-8.png)
> $\sum_{i=1}^n\sum^n_{j=i}1$
> $\sum_{i=1}^{n}n-i+1$
> $\sum^n_{i=1}n-\sum^n_{i=1}i+\sum^n_{i=1}1$
> FACT (given in exam): $\sum^n_{i=1}i=1+2+3+\dots+n=\frac{n(n+1)}{2}$
> $n(n-1+1)-\frac{n(n-1)}{2}+n$
> $\frac{n^2}{2}+\frac{n}{2}$


```cpp
#include <iostream>
using namespace std;

int main() {
    int s;
    cin >> s;

    int X[s];

    // Read array elements
    for (int i = 0; i < s; i++) {
        cin >> X[i];
    }

    // Check for uniqueness
    for (int i = 0; i < s - 1; i++) {
        for (int j = i + 1; j < s; j++) {
            if (X[i] == X[j]) {
                cout << "not unique" << endl;
                return 0;
            }
        }
    }

    cout << "unique values" << endl;
    return 0;
}
```

The following algorithm checks if a given integer array contains unique values. Write the time function.

> [!success]- Solution
> Worst-case scenario: when the array actually contains unique values. Here is the time
> ![image-2.png|400x163](/img/user/1%20-%20TR%20CMP340/img/image-2.png)
> ![image-9.png|400x344](/img/user/1%20-%20TR%20CMP340/img/image-9.png)



### Counting binary digits of a positive integer

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int counter = 0;

    while (n != 0) {
        n = n / 2;
        counter++;
    }

    cout << counter << endl;
    return 0;
}
```

> [!success]- Solve assuming n=15
> ![image-3.png|300](/img/user/1%20-%20TR%20CMP340/img/image-3.png)
> 
> ![image-10.png|400x294](/img/user/1%20-%20TR%20CMP340/img/image-10.png)
> 

Recursive time function?
> [!success]- Solution
> T(n)= 1 (first iteration) + T(n/2) remaining time to complete the rest of iterations

Number of steps (in this case, equivalent to nonrecursive time function)?
> [!success]- Solution
> You will always end with 1 before exiting the loop.
> 1/2 = 0 (int)
> $1=\frac{n}{2^k}$
> $2^k=n$
> $k=\log_{2}n$ (to reach 1)
> Therefore $t(n)=1+log_2(n)$ (# of steps to reach 0)

Nonrecursive time function?
1. telescoping method
2. generating functions
3. **time table method**

Perform **time table method** to find number of steps ⭐
> [!success]- Solution
> 
> | num of iterations | controlling variable   | computational cost<br>**(number of operations)** |
> | ----------------- | ---------------------- | ------------------------------------------------ |
> | 0                 | n (or $\frac{n}{2^0}$) | 1                                                |
> | 1                 | $\frac{n}{2^1}$        | 1                                                |
> | 2                 | $\frac{n}{2^2}$        | 1                                                |
> | 3                 | $\frac{n}{2^3}$        | 1                                                |
> | ...               | ...                    | ...                                              |
> | **k**             | **1**                  | 1                                                |
> |                   | 0                      |                                                  |
> We care about controlling variable value before 0. In this case, it is 1
> 
> $T(n) = 1+1+1+...+1$
> $\sum_{i=0}^{k}1=k+1$
> We cannot express time function using variables we don't have in the code. So we must rewrite T(n) to be in terms of n
> 
> $2^k=n$
> $\log_{2}2^k=\log_{2}n$
> $k\log_{2}{2}=\log_{2}n$
> $k\times {1}=\log_{2}n$
> $k=\log_{2}n$
> 
> Therefore: k + 1 ⇒ $log_2{(n)}+1$

### Linear Search: Find a value k in a given numeric array, A, of size n

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "enter array size: ";
    cin >> n;

    int A[n];

    // Read array elements
    for (int i = 0; i < n; i++) {
        cout << "enter element " << i << ": ";
        cin >> A[i];
    }

    int k;
    cout << "enter a value to search for: ";
    cin >> k;

    // Linear search (search for k in A)
    for (int i = 0; i < n; i++) {
        if (A[i] == k) {
            cout << k << " found at " << i << endl;
            return 0;
        }
    }

    cout << k << " is not found" << endl;
    return 0;
}
```

What is the time function of this algorithm?  
In the worst-case scenario where k is not found in the array, the time function is:
> [!success]- Solution
> Scan all elements to get answer
> $$T_{worst}(n)=\sum_{i=0}^{n-1}1+\sum_{i=0}^{n-1}1=n+n=2n$$

In the best-case scenario where k is not found in the array, the time function is? When is the best case?
> [!success]- Solution
> $T_{best}(n)=n (first loop) + 1 (second loop)$
> - first loop no matter what has to be run `n` times (because you're filling in the array elements). The second loop runs `1` time since best case would have the target as the first element in the array (meaning it runs 1 iteration of the loop)


Homework 1
![image-13.png|400x386](/img/user/1%20-%20TR%20CMP340/img/image-13.png)
