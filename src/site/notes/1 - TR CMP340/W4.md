---
{"dg-publish":true,"permalink":"/1-tr-cmp-340/w4/"}
---

range = max-min+1

---

**Selection Sort**

```C++
const int n = 4; int A[n] = { 9, 2, 5, 8 };
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        if (A[j] < A[i]) {
            int x = A[i];
            A[i] = A[j];
            A[j] = x;
        }
    }
}
for (int k = 0; k < n; k++) cout << A[k] << " ";
```

**Show the execution in detail (illustrating all data changes).**
$$T(n) = \sum_{i=0}^{n-1} \sum_{j=i+1}^{n-1} 1 \in O(n^2)$$
(Explain why?)
**S(n) = O(n) (why?)**

> [!success]- Do for {5, 2, 7, 1}
> ![image-42.png|400x711](/img/user/1%20-%20TR%20CMP340/img/image-42.png)
> > nested loop time complexity
> > 
> |**i**|**j**|**Comparison (A[j]<A[i])**|**Action**|**Array State (After Action)**|
> |---|---|---|---|---|
> |**0**|**1**|$2 < 5$ (**True**)|**Swap** 2 and 5|`[2, 5, 7, 1]`|
> |**0**|**2**|$7 < 2$ (False)|No Change|`[2, 5, 7, 1]`|
> |**0**|**3**|$1 < 2$ (**True**)|**Swap** 1 and 2|`[1, 5, 7, 2]`|
> |||_End of Pass i=0_|_Smallest is at A[0]_||
> |**1**|**2**|$7 < 5$ (False)|No Change|`[1, 5, 7, 2]`|
> |**1**|**3**|$2 < 5$ (**True**)|**Swap** 2 and 5|`[1, 2, 7, 5]`|
> |||_End of Pass i=1_|_2nd smallest is at A[1]_||
> |**2**|**3**|$5 < 7$ (**True**)|**Swap** 5 and 7|`[1, 2, 5, 7]`|
> |||_End of Pass i=2_|_3rd smallest is at A[2]_||
> |**3**||_Loop terminates_||`[1, 2, 5, 7]`|
> 
> 2) time complexity
> ![image-43.png|400x359](/img/user/1%20-%20TR%20CMP340/img/image-43.png)
> 
> 3) space complexity
> s(n)=n (input array) +constant (for 4 local variables, global variables, program itself)

> [!success]- For { 9, 2, 5, 8 } & time, space complexity
> ![image-79.png|400x538](/img/user/1%20-%20TR%20CMP340/img/image-79.png)
> > There is no pass by reference so its 6+n. If we passed by reference to a function the array, it'll be 7+n
> best and worst case is always same. Hence you can use $\Theta$

**Bubble sort**
```cpp
const int n = 4; int A[n] = { 10, 12, 5, 1 };
for (int i = n-1; i>=1; i--) {
    for (int j = 0; j < i; j++) {
        if (A[j+1] < A[j]) {
            int x = A[j];
            A[j] = A[j+1];
            A[j+1] = x;
        }
    }
}
for (int k = 0; k < n; k++) cout << A[k] << " ";
```
**Show the execution in detail (illustrating all data changes).**
$$T(n) = \sum_{i=1}^{n-1} \sum_{j=0}^{i-1} 1 \in O(n^2)$$
(Explain why? We did this simplification before.)
$$S(n) = n \quad \text{Why?}$$

> [!success]- Do for {10, 12, 5, 1}
> ![image-78.png|400x347](/img/user/1%20-%20TR%20CMP340/img/image-78.png)
> You can write $\Theta$

> [!success]- Do for {5 12 4 9}
> |**i (Limit)**|**j**|**Comparison (A[j+1]<A[j])**|**Action**|**Array State**|
> |---|---|---|---|---|
> |**3**|**0**|$12 < 5$ (False)|No Swap|`{ 5, 12, 4, 9 }`|
> ||**1**|$4 < 12$ (**True**)|**Swap** 12 and 4|`{ 5, 4, 12, 9 }`|
> ||**2**|$9 < 12$ (**True**)|**Swap** 12 and 9|`{ 5, 4, 9, 12 }`|
> |||_End of Pass i=3_|_12 is locked_||
> |**2**|**0**|$4 < 5$ (**True**)|**Swap** 5 and 4|`{ 4, 5, 9, 12 }`|
> ||**1**|$9 < 5$ (False)|No Swap|`{ 4, 5, 9, 12 }`|
> |||_End of Pass i=2_|_9 is locked_||
> |**1**|**0**|$5 < 4$ (False)|No Swap|`{ 4, 5, 9, 12 }`|
> |||_End of Pass i=1_|_5 is locked_||
> |**End**||||`{ 4, 5, 9, 12 }`|
> **Final Output:** `4 5 9 12`
> 
> Same time and space complexity as previous q


**Insertion sort**
```cpp
const int n = 4; int A[n] = { 10,12,5,1 };
for (int i = 1; i<n; i++) {
    int v = A[i]; int j;
    for (j = i-1; j >=0; j--) {
        if (v > A[j])
            break;
        A[j + 1] = A[j];
    }
    A[j+1] = v;
}
for (int k = 0; k < n; k++) cout << A[k] << " ";
```
1) **Show the execution in detail (illustrating all data changes).**
2) Time and Space Complexity

> [!success]- Do for 10, 12, 5, 1
> ![image-80.png|400x431](/img/user/1%20-%20TR%20CMP340/img/image-80.png)

> [!success]- Solve for 7 2 5 1
> Careful in the code when u exit inner loop normally j-- makes it so that j=-1 before the operation `A[j+1]=v`, so `A[j+1]` in this case is `A[0]`.
> 
> |**i**|**v (Value to Insert)**|**j**|**Comparison (v>A[j]?)**|**Action**|**Array State**|
> |---|---|---|---|---|---|
> |**1**|**2**|**0**|$2 > 7$ (False)|Shift 7 to right|`{ 7, 7, 5, 1 }`|
> |||**-1**|Loop ends|**Insert 2** at `A[0]`|`{ 2, 7, 5, 1 }`|
> ||||_End of Pass i=1_|||
> |**2**|**5**|**1**|$5 > 7$ (False)|Shift 7 to right|`{ 2, 7, 7, 1 }`|
> |||**0**|$5 > 2$ (**True**)|**Break** (Stop shifting)|`{ 2, 7, 7, 1 }`|
> |||||**Insert 5** at `A[1]`|`{ 2, 5, 7, 1 }`|
> ||||_End of Pass i=2_|||
> |**3**|**1**|**2**|$1 > 7$ (False)|Shift 7 to right|`{ 2, 5, 7, 7 }`|
> |||**1**|$1 > 5$ (False)|Shift 5 to right|`{ 2, 5, 5, 7 }`|
> |||**0**|$1 > 2$ (False)|Shift 2 to right|`{ 2, 2, 5, 7 }`|
> |||**-1**|Loop ends|**Insert 1** at `A[0]`|`{ 1, 2, 5, 7 }`|
> ![image-44.png|400x270](/img/user/1%20-%20TR%20CMP340/img/image-44.png)
> > in best case we dont use inner loop cause we always break when we enter
> 
> ![image-45.png|400x244](/img/user/1%20-%20TR%20CMP340/img/image-45.png)


**Counting sort**
```cpp
const int n = 7; int A[n] = { 8,6,9,6,8 };
const int min = 6, max = 9;
const int m = max - min + 1;
int B[m] = { 0 };
int C[n];
for (int i = 0; i<n; i++){
    B[A[i] - min] += 1;
}
for (int i = 0; i < m-1; i++) {
    B[i + 1] += B[i];
}
for (int i = 0; i < n; i++) {
    C[B[A[i] - min]-1] = A[i];
    B[A[i] - min]--;
}
for (int k = 0; k < n; k++) cout << C[k] << " ";
```
**The running time is linear O(m+n), why?**
**The space is linear O(m+n), why?**
**This is an example of trading space for time. (Explain?)**
**Exercise: show the execution with A=3,5,6,3,4,5**

> [!success]- Show for 9 6 7 6
> ![image-81.png|400x411](/img/user/1%20-%20TR%20CMP340/img/image-81.png)
> ![image-82.png|400x306](/img/user/1%20-%20TR%20CMP340/img/image-82.png)
> ![image-46.png|400x225](/img/user/1%20-%20TR%20CMP340/img/image-46.png)


**Radix sort:**
**show the execution with Array=[30, 5, 125, 14];**
**calculate the time and space complexity**
```cpp
void RadixSort(vector<int> &Array, int n) {
    bool stop = false;
    int digit = 0;
    while (!stop) {
        vector<int> row;
        vector<vector<int>> Buckets(10, row);
        stop = true;
        digit++;
        for (int i = 0; i < n; i++) {
            int r = Array[i] % (int)pow(10, digit);
            r = r / (int)pow(10, digit - 1);
            if (r != 0) stop = false;
            Buckets[r].push_back(Array[i]);
        }
        if (stop) break;
        int k = 0;
        for (int i = 0; i <= 9; i++) 
            for (int j = 0; j < Buckets[i].size(); j++)
                Array[k++] = Buckets[i][j];
    }
}


void main()
{
//just inputs and prints
    int n;
    cout << "enter array size: ";
    cin >> n;
    vector<int> Array(n);
    cout << "enter array values: ";
    for (int i = 0; i < n; i++)
        cin >> Array[i];
    RadixSort(Array, n);
    cout << "sorted array: ";
    for (int i = 0; i < n; i++)
        cout << Array[i] << " ";
    cout << endl;
}
```

> [!success]- Solution for {105, 5, 17, 24}
> ![image-84.png|400x227](/img/user/1%20-%20TR%20CMP340/img/image-84.png)
> ![image-83.png|400x304](/img/user/1%20-%20TR%20CMP340/img/image-83.png)
![image-47.png|400x202](/img/user/1%20-%20TR%20CMP340/img/image-47.png)

> [!success]- Solution for {31, 8, 118, 3}
> 
> ### Pass 1: digit = 1 (ones place)
> We extract the **ones digit** using `Array[i] % 10`.
> 
> |Element|Ones Digit|Bucket|
> |---|---|---|
> |31|1|Bucket[1]|
> |8|8|Bucket[8]|
> |118|8|Bucket[8]|
> |3|3|Bucket[3]|
> 
> **Buckets after Pass 1:**
> 
> |0|1|2|3|4|5|6|7|8|9|
> |---|---|---|---|---|---|---|---|---|---|
> ||31||3|||||8, 118||
> 
> **Collect back:** Array = [**31, 3, 8, 118**]
> 
> `stop = false` because at least one `r != 0` (31→1, 8→8, 118→8, 3→3). ✅ Continue.
> 
> ![image-48.png|400x227](/img/user/1%20-%20TR%20CMP340/img/image-48.png)
> 
> ---
> 
> ### Pass 2: digit = 2 (tens place)
> 
> We extract the **tens digit** using `(Array[i] % 100) / 10`.
> 
> |Element|Tens Digit|Bucket|
> |---|---|---|
> |31|3|Bucket[3]|
> |3|0|Bucket[0]|
> |8|0|Bucket[0]|
> |118|1|Bucket[1]|
> 
> **Buckets after Pass 2:**
> 
> |0|1|2|3|4|5|6|7|8|9|
> |---|---|---|---|---|---|---|---|---|---|
> |3, 8|118||31|||||||
> 
> **Collect back:** Array = [**3, 8, 118, 31**]
> 
> `stop = false` because some `r != 0` (31→3, 118→1). ✅ Continue.
> 
> ![image-49.png|400x309](/img/user/1%20-%20TR%20CMP340/img/image-49.png)
> 
> ---
> 
> ### Pass 3: digit = 3 (hundreds place)
> 
> We extract the **hundreds digit** using `(Array[i] % 1000) / 100`.
> 
> |Element|Hundreds Digit|Bucket|
> |---|---|---|
> |3|0|Bucket[0]|
> |8|0|Bucket[0]|
> |118|1|Bucket[1]|
> |31|0|Bucket[0]|
> 
> **Buckets after Pass 3:**
> 
> |0|1|2|3|4|5|6|7|8|9|
> |---|---|---|---|---|---|---|---|---|---|
> |3, 8, 31|118|||||||||
> 
> **Collect back:** Array = [**3, 8, 31, 118**] ✅ Sorted!
> 
> `stop = false` because 118→1 != 0. ✅ Continue.
> 
> ![image-50.png|400x332](/img/user/1%20-%20TR%20CMP340/img/image-50.png)
> 
> ---
> 
> ### Pass 4: digit = 4 (thousands place) ‼️(dont forget)
> 
> All elements have a thousands digit of **0**, so `r = 0` for every element → `stop` stays `true` → **break!**
> 
> **Final sorted array: [3, 8, 31, 118]** ✅
> 
> ---
> 
> ## Time Complexity
> 
> Let m be the max number of digits.
> T(n,m) = m\[n+2n\]=O(mn)
> - m is while loop
> 
> Where **m = ⌊log₁₀(max)⌋ + 1**. In our example, max = 118, so m = 3 (plus the extra check pass).
> 
> ![image-51.png|400x711](/img/user/1%20-%20TR%20CMP340/img/image-51.png)
> 
> ---
> 
> ## Space Complexity
> 
> **What extra memory do we use?**
> 
> - **10 buckets** (vectors), which collectively hold all **n** elements each pass.
> - No matter how elements are distributed, the total across all buckets is always **n**.
> 
> > **Space Complexity = O(n + 10) = O(n)**
> 
> The `+ 10` comes from the bucket array itself, but it's constant and drops out.
> 
> 


---

![image-52.png|400x226](/img/user/1%20-%20TR%20CMP340/img/image-52.png)
> merge sorted subarrays



```cpp
void MergeSort(int A[], int a) {
    if (a > 1) {
        int B[a / 2];
        for (int i = 0; i < a / 2; i++)
            B[i] = A[i];
        MergeSort(B, a / 2);

        int C[a - a / 2];
        for (int i = 0; i < (a - a / 2); i++)
            C[i] = A[i + a / 2];
        MergeSort(C, a - a / 2);

        Merge(A, a, B, a / 2, C, a - a / 2);
    }
}
```

```cpp
void Merge(int A[], int a, int B[], int b, int C[], int c) {
    int i = 0, j = 0, k = 0;
    while (i < b && j < c) {
        if (B[i] <= C[j]) {
            A[k] = B[i]; k++; i++;
        }
        else {
            A[k] = C[j]; k++; j++;
        }
    }
    while (i < b) { A[k] = B[i]; i++; k++; }
    while (j < c) { A[k] = C[j]; k++; j++; }
}
```

> [!success]- Show execution for mergesort(\[3,1,5,2\],4)
> ![image-53.png|400x225](/img/user/1%20-%20TR%20CMP340/img/image-53.png)
> ![image-85.png|400x202](/img/user/1%20-%20TR%20CMP340/img/image-85.png)

Time and space is not included in exam. 


**How it works:**  
<span style="color:red">① Split</span> the array in half, recursively, until each piece is size 1.  
<span style="color:green">② Merge</span> sorted pieces back by comparing front elements.

