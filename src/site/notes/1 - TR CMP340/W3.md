---
{"dg-publish":true,"permalink":"/1-tr-cmp-340/w3/"}
---

Lecture 5.pptx

Formula (given in exam):
$$\sum_{i=0}^nx^i=\frac{x^{n+1}-1}{x-1}$$
Rule (not given in exam):
$$2^{\log_{2}n}=n^{\log_{2}2}$$

---

Recursive Algorithms (Exponential Time): Given the following algorithmic structure.

```cpp
void f(int n) {
    cout << "the function is entered with n= " << n << endl;
    if (n == 1) return;
    f(n - 1);
    f(n - 1);
}

int main() {
    int n; cin >> n;
    f(n);
    return 0;
}
```

Exercise: Show the execution of the algorithm for n=3.

Exercise: Show how the execution of the algorithm can be visualized as a tree.

Evaluate the time and space complexity of the algorithm.  
(The complexity table is given in the next slide.)

Exercise: add a third call f(n-1) after the second recursive call in the recursion f.  
Repeat the analyses above on the new version of the algorithmic structure.

> [!success]- Call stack execution
> (max size of stack is n ⇒ 4)
> Here’s the **call stack evolution** for `f(3)` (top of stack is the **last line**).  
> Code does: print, if, then **first** `f(n-1)`, then **second** `f(n-1)`.
> ---
> ### Start
> **Push f(3)**
> ```
> f(3)
> ```
> ### First recursive call from f(3): f(2)
> **Push f(2)**
> ```
> f(3)
> f(2)
> ```
> ### First recursive call from f(2): f(1)
> **Push f(1)** (base case, returns immediately)
> ```
> f(3)
> f(2)
> f(1)
> ```
> **Pop f(1)**
> ```
> f(3)
> f(2)
> ```
> ### Second recursive call from f(2): f(1)
> **Push f(1)** (base case)
> ```
> f(3)
> f(2)
> f(1)
> ```
> **Pop f(1)**
> ```
> f(3)
> f(2)
> ```
> ### f(2) finished
> **Pop f(2)**
> ```
> f(3)
> ```
> ---
> ### Second recursive call from f(3): f(2)
> **Push f(2)**
> ```
> f(3)
> f(2)
> ```
> ### First recursive call from this f(2): f(1)
> **Push f(1)**
> ```
> f(3)
> f(2)
> f(1)
> ```
> **Pop f(1)**
> ```
> f(3)
> f(2)
> ```
> ### Second recursive call from this f(2): f(1)
> **Push f(1)**
> ```
> f(3)
> f(2)
> f(1)
> ```
> **Pop f(1)**
> ```
> f(3)
> f(2)
> ```
> ### f(2) finished
> **Pop f(2)**
> ```
> f(3)
> ```
> ### f(3) finished
> **Pop f(3)**
> ```
> (empty)
> ```
> ---
> This matches the printed order:  
> `3, 2, 1, 1, 2, 1, 1` (7 calls total).
> 

> [!success]- Tree execution
> Shown for n=4
> ![WIN_20260127_12_35_30_Pro.jpg|400x225](/img/user/1%20-%20TR%20CMP340/img/WIN_20260127_12_35_30_Pro.jpg)

> [!success]- Time and space complexity
> Space complexity = O(n) → you always release space when its done.
> Time complexity = O($2^n$)

> [!success]- Proof of time and space complexity
> ![image-27.png|400x400](/img/user/1%20-%20TR%20CMP340/img/image-27.png)
> 
> | call tree level | controlling var.            | time                                                       | space (stack)                                                                |
> | --------------- | --------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------------------------- |
> | 0               | n-0                         | 1 ($2^0$)                                                  | 1                                                                            |
> | 1               | n-1                         | 2 ($2^1$ , for two sides of the binary tree)               | 1 (once we're done with first call, we reuse that space for the second call) |
> | 2               | n-2                         | $2^2$ (now it has four sides in this level of binary tree) | 1                                                                            |
> | ...             | ...                         | ...                                                        | ...                                                                          |
> | k               | 1=n-k<br>$\therefore k=n-1$ | $2^k$                                                      | 1                                                                            |
> S(n)=$\sum_{{i=0}}^k 1=k+1=O(n)$ 
> T(n)=$\sum_{i=0}^k{2}^i=2^{k+1}-1$
> $=2^n-1=O(2^n)$
> 

> [!success]- What if we have 3 calls?
> ![WIN_20260127_12_56_14_Pro.jpg|400x225](/img/user/1%20-%20TR%20CMP340/img/WIN_20260127_12_56_14_Pro.jpg)

Space complexity = max size of stack (or tree levels)
Time complexity = whole tree size (all calls)


Recursive Algorithms (Linearithmic Time): Given the following algorithmic structure.

```cpp
int m;
#include<iostream>
using namespace std;
void f(int n) {
    cout << "the function is entered with n= " << n << endl;
    if (n == 1) return;
    for (int i = 1; i <= m; i++)
        cout << i << " ";
    cout << endl;
    f(n/2);
}
int main() {
    int n; cin >> n; m = n;
    f(n);
}
```

Exercise: Show the detailed execution of the algorithm above for n=8.

Evaluate the time and space complexity of the algorithm above.  
(The complexity table is given in the next slide.)

> [!success]- Solution
> 
> | calls | controlling var.                          | time                                 | space |
> | ----- | ----------------------------------------- | ------------------------------------ | ----- |
> | o     | $\frac{n}{2^0}$                           | m (for loop)                         | 1     |
> | 1     | $\frac{n}{2^1}$                           | m                                    | 1     |
> | 2     | $\frac{n}{2^2}$                           | m                                    | 1     |
> | .     | .                                         | .                                    | .     |
> | k     | $\frac{n}{2^k}$=1 (terminating condition) | 1 (no need to run loop in last call) | 1     |
> 
> T(n)=$\sum_{i=0}^{k-1}m=mk$
> 
> we dont have k so we need to solve for k from controlling var. (but we know n=m because its initialized with n)
> 
> $1=\frac{n}{2^k}$
> $n=2^k$
> $\log_{2}n=k$
> $k=\log n$   (log n = $\log_{2}n$ in CMP (algorithmic analysis))
> 
> Now we can replace k. 
> 
> T(n)=$\sum_{i=0}^{k-1}m=mk$
> $=n\log n$
> $=O(n\log n)$
> 
> S(n)=$\sum^k_{i=0}1=O(\log n)$
> 
How many calls?
> [!success]- Solution
> $\log_{2}8+1=4$


```cpp
int m;
#include<iostream>
using namespace std;
void f(int n) {
    cout << "the function is entered with n= " << n << endl;
    if (n == 1) return;
    for (int i = 1; i <= n; i++)
        cout << i << " ";
    cout << endl;
    f(n/2);
}
int main() {
    int n; cin >> n; m = n;
    f(n);
}
```

Exercise: Show the detailed execution of the algorithm above for n=8.  
Evaluate the time and space complexity of the algorithm above.  
(The complexity table is given in the next slide.)

> [!success]- Solution
> 
> | calls | controlling var.                          | time                | space |
> | ----- | ----------------------------------------- | ------------------- | ----- |
> | o     | $\frac{n}{2^0}$                           | $\frac{n}{2^0}$=n   | 1     |
> | 1     | $\frac{n}{2^1}$                           | $\frac{n}{2^1}$     | 1     |
> | 2     | $\frac{n}{2^2}$                           | $\frac{n}{2^2}$     | 1     |
> | ...   | ...                                       | ...                 | ...   |
> | k-1   | 2                                         | $\frac{n}{2^{k-1}}$ | 1     |
> | k     | $\frac{n}{2^k}$=1 (terminating condition) | 1                   | 1     |
> S(n)=$\sum_{i=0}^k 1=k+1=O(\log n)$ ( we found this out previously from controlling variable)
> T(n) = 
> ![WIN_20260127_13_21_12_Pro.jpg|400x225](/img/user/1%20-%20TR%20CMP340/img/WIN_20260127_13_21_12_Pro.jpg)
> Formula:
> $$\sum_{i=0}^nx^i=\frac{x^{n+1}-1}{x-1}$$
> Rule:
> $$2^{\log_{2}n}=n^{\log_{2}2}$$



Binary Recursive Algorithm with Linear Time: Given the following algorithmic structure.

```cpp
void f(int n) {
    cout << "entered with n= " << n << endl;
    if (n == 1) return;
    f(n / 2);
    f(n / 2);
    cout << endl;
}

int main() {
    int n; cin >> n;
    f(n);
}
```

Exercise: Show the detailed execution of the algorithm above for n=4.

Evaluate the time and space complexity of the algorithm above.  
(The complexity table is given in the next slide.)



| call tree levels | controlling var.                                    | time      | space |
| ---------------- | --------------------------------------------------- | --------- | ----- |
| 0                | $\frac{n}{2^0}$                                     | 1 ($2^0$) | 1     |
| 1                | $\frac{n}{2^1}$                                     | 2 ($2^1$) | 1     |
| 2                | $\frac{n}{2^2}$                                     | 4 ($2^2$) | 1     |
| ...              | ...                                                 | ...       | ...   |
| k                | $\frac{n}{2^k}$=1<br>k=log(n) → previously derived. | $2^k$     | 1     |
S(n)=$\sum_{i=0}^k 1=k+1=O(\log n)$
T(n)=$\sum_{i=0}^k=2^i$
$=\frac{2^{k+1}-1}{2-1}$
$=2\cdot 2^{\log_{2}n}-1$
$=2\cdot n^{\log_{2}2}-1$
$=O(n)$


