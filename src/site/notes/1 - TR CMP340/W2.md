---
{"dg-publish":true,"permalink":"/1-tr-cmp-340/w2/"}
---




$$T_{1}(n)=2n+100$$
$$T_{2}(n)=2n$$
> [!info] 
> No meaningful difference.
> > [!warning]
> > Do not compare time functions, instead compare **growth orders** 

Growth order: highest degree term


Case 1: **f(n) has higher growth order**
$$\lim_{n\to\infty}\frac{f(n)}{g(n)}=\infty$$


Case 2: **Same growth order**
$$\lim_{n\to\infty}\frac{f(n)}{g(n)}=\text{constant}$$

Case 3: **g(n) has higher growth order**
$$\lim_{n\to\infty}\frac{f(n)}{g(n)}=0$$


$f(n)=8n^2+n+4$
$g(n)=n^2+135$
State growth-order relationship
> [!success]- Solution
> $$\lim_{n\to\infty}\frac{8n^2+n+4}{n^2+135}$$
> divide top and bottom by $n^2$
> $$=\lim_{n\to\infty}\frac{8+\frac{1}{n}+\frac{4}{n^2}}{1+\frac{135}{n^2}}
= \frac{8+0+0}{1+0}=8$$
$$f(n)\in \Theta(g(n)) \quad\text{(same growth order)}$$


$f(n)=\sqrt{n}$
$g(n)=1+\log n$
State growth-order relationship
> [!success]- Solution
> $$\lim_{n\to\infty}\frac{\sqrt{n}}{1+\log n}$$
> Use l'hopital
> $$=\lim_{n\to\infty}\frac{\frac{d}{dn}\sqrt{n}}{\frac{d}{dn}(1+\log n)}
=\lim_{n\to\infty}\frac{\frac{1}{2\sqrt{n}}}{\frac{1}{n}}
=\lim_{n\to\infty}\frac{n}{2\sqrt{n}}
=\lim_{n\to\infty}\frac{\sqrt{n}}{2}
=\infty$$

> [!note]
> The simplification is not coming in exam
> 
> **Professor, how would you ask about this?**
*Verbose answer*: MCQ give 2 functions. The limit is equal to X. What's the conclusion? how to relate? how do you compare this to the other function? 
*Direct answer*: MCQ. Which of the 3 cases is this?

Compare growth order of $log_en$ with $log_an$, where e is Euler's number and a is positive real number.
> [!success]- Solution
> 
> $$\lim_{n\to\infty}\frac{\log_e n}{\log_a n}$$
> $$\dfrac{d}{dn}\log_e n = \dfrac{1}{n}$$
> $$\log_a n = \dfrac{\ln n}{\ln a}\Rightarrow \dfrac{d}{dn}\log_a n = \dfrac{1}{n\ln a}$$
>
> $${\lim_{n\to\infty}\frac{\log_e n}{\log_a n}
> =
> \lim_{n\to\infty}\frac{\frac{1}{n}}{\frac{1}{n\ln a}}
> =
> \lim_{n\to\infty} \ln a
> =
> \ln a}$$

> [!important] 
> This is proof that, regardless of the base, logarithms have the **SAME growth order**

Sort the following functions from smallest growth rate to largest:
1. $T_1(n) = n^3$
2. $T_2(n) = 2^n$
3. $T_3(n) = n!$
4. $T_4(n) = 3^n$
5. $T_5(n) = n \ln n$

> [!success]- Solution
> ### **1. Current Progress (From Image)**
> The solution in the image has already established two key relationships using limits:
> - **$T_5 < T_1$**: Log-linear ($n \ln n$) grows slower than Polynomial ($n^3$).
> - **$T_1 < T_2$**: Polynomial ($n^3$) grows slower than Exponential ($2^n$).
> **Current Order:** $T_5 < T_1 < T_2$
> ---
> ### **2. Completing the Check**
> To finish the sort, we need to place the remaining functions: $T_4(n) = 3^n$ and $T_3(n) = n!$.
> #### **Step A: Compare $T_2(n)$ and $T_4(n)$**
> We compare the two exponentials: $2^n$ and $3^n$.
> $$\lim_{n \to \infty} \frac{2^n}{3^n} = \lim_{n \to \infty} \left(\frac{2}{3}\right)^n = 0$$
> Since the limit is 0, the denominator grows faster.
> Result: $T_2 < T_4$
> #### **Step B: Compare $T_4(n)$ and $T_3(n)$**
> We compare the exponential $3^n$ with the factorial $n!$. We can use the ratio test concept or simply limits.
> $$\lim_{n \to \infty} \frac{3^n}{n!}$$
> Expanding this logic:
> $$\frac{3 \cdot 3 \cdot \dots \cdot 3}{1 \cdot 2 \cdot \dots \cdot n}$$
> As $n$ gets large, the terms in the denominator (like $n, n-1$) become much larger than the base 3 in the numerator.
> Using Stirling's approximation or standard hierarchy rules, we know that factorial dominates exponential growth.
> Result: $T_4 < T_3$
> ---
> ### **3. Final Solution**
> Combining the steps from the image and our completion:
> 1. **Smallest:** $T_5(n) = n \ln n$
> 2. $T_1(n) = n^3$
> 3. $T_2(n) = 2^n$
> 4. $T_4(n) = 3^n$
> 5. **Largest:** $T_3(n) = n!$
> Final Order:
> $$T_5 < T_1 < T_2 < T_4 < T_3$$

### Growth Order Hierarchy
**Most Efficient (Fastest) $\downarrow$**
1. **$O(1)$** _(Constant - e.g., accessing an array index)_
2. **$O(\ln n)$** _(Logarithmic - e.g., binary search)_ **$\leftarrow$ [Log of n]**
3. **$O(\sqrt{n})$** _(Square root - e.g., primality test)_ **$\leftarrow$ [Square root of n]**
4. **$O(n)$** _(Linear - e.g., simple loop)_
5. **$O(n \ln n)$** _(Linearithmic - e.g., Merge Sort)_
6. **$O(n^2)$** _(Quadratic - e.g., nested loops)_ **$\leftarrow$ [Quadratic]**
7. **$O(n^3)$** _(Cubic - e.g., standard matrix multiplication)_
8. **$O(2^n)$** _(Exponential base 2 - e.g., subsets of a set)_
9. **$O(3^n)$** _(Exponential base 3)_
10. **$O(n!)$** _(Factorial - e.g., permutations)_
11. $O(n^n)$ (Hyper-exponential)
    **$\uparrow$ Least Efficient (Slowest)**

|**Symbol**|**Name**|**Math Meaning**|**Practical Meaning**|
|---|---|---|---|
|**$O$**|Big O|$\le$ (Less than or equal)|**Worst Case** (Upper Bound)|
|**$\Omega$**|Big Omega|$\ge$ (Greater than or equal)|**Best Case** (Lower Bound)|
|**$\Theta$**|Big Theta|$=$ (Equal growth rate)|**Tight Bound** (Exact Growth)|

$n \in O(n^2)$
$n^3 \not\in O(n^2)$
$\text{constant}\in O(1)$
$2^n \in O(n!)$
$n^n \in O(n!)$

$n \in \Theta(n+100)$
$n^2 \in \Theta(n^2+n+5)$
$\sqrt{ n } \not\in \Theta (n+\log n)$

$n^3\in \Omega (1)$
$\sqrt{ n }\in \sqrt{ \log n }$
$n \not\in \Omega(n\log n)$

Linear search
- best T(n)=1
- Worst T(n)=n
Which notation best describes the notation here?
> [!success]- Solution
> The LS runs in 
> - O(n) (**Worst Case** / upper bound) 
> - $\Omega(1)$ (**Best case** / lower bound) 

Find min in array with n elements. Runs in what time?
> [!success]- Solution
> Finding the minimum value in an unsorted array requires checking every single element. Therefore it runs in $\Theta(n)$
> - You turn over the first card. It's a "5".
> - To be 100% sure "5" is the lowest, you **must** turn over the second card.
> - You must continue until you have turned over **every single card**.


##### Non-recursive Algorithms versus Recursive Algorithms
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // non recursive: find the min in a given array
    int n = 3;
    
    // 1. Create the vector (allocates memory -> Space O(n))
    vector<int> A(n); 
    
    // 2. Initialize the values
    A = { 7, 2, 9 }; 
    
    // 3. Assume the first element is the minimum
    int min = A[0]; 
    
    // 4. Loop through the array (Time O(n))
    for (int i = 0; i < n; i++) {
        if (A[i] < min) {
            min = A[i];
        }
    }
    
    // 5. Output the result
    cout << min << endl;

    return 0;
}
```

Space function?
> [!success]- Solution
> S( ) = count the locations
> = 1 (`n=3`) + n (`A - list itself`) + 1 (`A - reference/name`) + 1 (`min`) + 1 (`i`) + 1(`main`)
> = n + 5
> | prof said 1 was added for main(), confirm with Dr.
> O(n) space 

Time complexity?
Space complexity?
> [!success]- Solution
> - **Time Complexity:** Θ(n) (Because the loop runs `n` times).
> - **Space Complexity:** O(n) (Because `vector<int> A(n)` creates a new list that takes up memory proportional to `n`).

For the recursive version, FindMinRec(), what is the stop case? recursive case?
**Stop case: when 1 element left in array**
if (n == 1) 
    return A[0];
**Recursive case**
```cpp
int FindMinRec(vector<int>& A, int n) {
    // 1. STOP CASE
    if (n == 1) {
        return A[0];
    }
    
    // 2. RECURSIVE CASE
    int minOfRest = FindMinRec(A, n - 1);
    
    if (A[n - 1] < minOfRest) {
        return A[n - 1];
    } else {
        return minOfRest;
    }
}
```
Alternative (prof way):
```cpp
// find the minimum value in a given array recursively

int FindMin(vector<int> &A, int n, int min, int i) {
    if (i < n) {
        if (A[i] < min) min = A[i];
        return FindMin(A, n, min, i + 1);
    }
    else {
        return min;
    }
}

int main()
{
    int n = 3;
    vector<int> A(n);
    A = { 7, 2, 9 };
    // Note: The slide calls it with i starting at 0 and min starting at A[0]
    cout << FindMin(A, n, A[0], 0) << endl;
    return 0;
}
```

Do execution of algorithm when A is array with four values: 7, 4, 8, 3
> [!success]- Solution
> ![WIN_20260122_12_40_10_Pro.jpg|400x225](/img/user/1%20-%20TR%20CMP340/img/WIN_20260122_12_40_10_Pro.jpg)

1. Explain the execution of this algorithm when A is an array with three values: 7,2,9.  
2. Is the time and space of this algorithm different from the non-recursive version?
3. Calculate space complexity

> [!success]- Solution [1,2]
> Q1.
> ![WIN_20260120_13_39_47_Pro.jpg|400x225](/img/user/1%20-%20TR%20CMP340/img/WIN_20260120_13_39_47_Pro.jpg)
> Q2.
> 
> |**Metric**|**Non-Recursive (Iterative)**|**Recursive**|**Verdict**|
|---|---|---|---|
|**Time**|**$\Theta(n)$**|**$\Theta(n)$**|**SAME.** Both must visit every element exactly once.|
|**Space**|**$O(1)$** (Auxiliary)|**$O(n)$** (Auxiliary)|**DIFFERENT.** Recursive is worse. Because every call makes a new set of variables|
> 

> [!success]- Solution [3]
> 
> s(n)=input + output + computational variables + call stack
> s(n) = n (elements) + 1  (1 integer return) + 2 (A list, pointer of A) + n (n recursive calls) {call stack needs formal demonstration} ⇒ O(n)
> 
> Formal demonstration of call stack (complexity table):
> 
> | # of iteration | controlling var. <br>(decides how many times a loop runs → i) | Computational cost                         | Space (call stack)                  |
> | -------------- | ------------------------------------------------------------- | ------------------------------------------ | ----------------------------------- |
> | 0              | 0                                                             | 1  (always if else statement, so always 1) | 1                                   |
> | 1              | 1                                                             | 1                                          | 1                                   |
> | 2              | 2                                                             | 1                                          | 1                                   |
> | ...            | ...                                                           | ...                                        | ...                                 |
> | k=n            | n (last value for i)                                          | 1                                          | 1                                   |
> |                |                                                               | $T(n)=\sum_{i=0}^k {1}=k+1$<br>= O(n)      | $S(n)=\sum_{i=0}^k 1=k+1$<br>= O(n) |
> 


![image-19.png|400x220](/img/user/1%20-%20TR%20CMP340/img/image-19.png)

Complete complexity table

> [!success]- Solution
> ![image-20.png|400x234](/img/user/1%20-%20TR%20CMP340/img/image-20.png)
> $T(n)=\sum_{i=0}^k {1}=k+1=n=O(n)$


![image-21.png|400x345](/img/user/1%20-%20TR%20CMP340/img/image-21.png)

Compute time and space complexity

> [!success]- Solution
> $\sum_{i=2}^k 1=n-1 \implies O(n)$
> $S(n)=\text{constant}\in O(1)$
> OPTIONALLY:
> ![image-22.png|400x200](/img/user/1%20-%20TR%20CMP340/img/image-22.png)


---
> [!info] Note
> In exam it will be like: 
> use the ∑ (sum) operator to find time of non-recursive definition (so no need to construct complexity table, its easier for non-recursive)

---

```cpp
#include <iostream>
#include <vector>

using namespace std;


bool f(int i, vector<int> &A, int n) {
    if (i == n) return true;

    for (int j = i + 1; j < n; j++) {
        if (A[i] == A[j]) {
            return false;
        }
    }

    return f(i + 1, A, n);
}

int main() {
    int n = 4;
    vector<int> A(n);
    A = { 3, 6, 3, 9 };

    cout << f(0, A, n) << endl;
    
    return 0;
}
```

Track the call (Exam type of q ⭐)
> [!success]- Solution
> ![image-23.png|400x197](/img/user/1%20-%20TR%20CMP340/img/image-23.png)

Space/time complexity
> [!success]- Solution
> ![image-24.png|400x372](/img/user/1%20-%20TR%20CMP340/img/image-24.png)
> ![image-25.png|400x452](/img/user/1%20-%20TR%20CMP340/img/image-25.png)
> (we got n-i through this way):
> ![image-26.png|400x192](/img/user/1%20-%20TR%20CMP340/img/image-26.png)


Write a recursive algorithm for the sequential search for some value k in a given array. Discuss the time and space of your algorithm.

```cpp
int RecSeqSearch(int i, int n, int k, vector<int> A)
	if (i==n) return -1; //-1 = not found
	if (A[i]==k) return i; //return position
	return RecSeqSearch(i+1,n,k,A);
```

Best case:
if k=A[0] → O(1)
Worst case:
if k=A[n] → O(n) //last element of array
OR
$\text{if }k\neq A[i]\,\forall \,i$
T(n)=$\sum_{i=0}^n 1 = n+1=O(n)$

Write a recursive algorithm that finds the number of bits in the binary representation of a positive integer. Discuss the time and space of your algorithm.


